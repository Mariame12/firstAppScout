"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const error_1 = __importDefault(require("@pnpm/error"));
const can_write_to_dir_1 = require("can-write-to-dir");
const path_name_1 = __importDefault(require("path-name"));
function default_1(knownCandidates = [], { shouldAllowWrite = true } = {}) {
    var _a, _b;
    if (!process.env[path_name_1.default]) {
        throw new error_1.default('NO_PATH_ENV', `Couldn't find a global directory for executables because the "${path_name_1.default}" environment variable is not set.`);
    }
    const dirs = (_b = (_a = process.env[path_name_1.default]) === null || _a === void 0 ? void 0 : _a.split(path_1.default.delimiter)) !== null && _b !== void 0 ? _b : [];
    const nodeBinDir = path_1.default.dirname(process.execPath);
    return pickBestGlobalBinDir(dirs, [
        ...knownCandidates,
        nodeBinDir,
    ], shouldAllowWrite);
}
exports.default = default_1;
const areDirsEqual = (dir1, dir2) => path_1.default.relative(dir1, dir2) === '';
function pickBestGlobalBinDir(dirs, knownCandidates, shouldAllowWrite) {
    const noWriteAccessDirs = [];
    const pnpmDir = dirs.find((dir) => isUnderDir('pnpm', dir.toLowerCase()));
    if (pnpmDir != null) {
        if (canWriteToDirAndExists(pnpmDir))
            return pnpmDir;
        throw new error_1.default('PNPM_DIR_NOT_WRITABLE', `The CLI has no write access to the pnpm home directory at ${pnpmDir}`);
    }
    for (const dir of dirs) {
        const lowCaseDir = dir.toLowerCase();
        if ((isUnderDir('node', lowCaseDir) ||
            isUnderDir('nodejs', lowCaseDir) ||
            isUnderDir('npm', lowCaseDir) ||
            knownCandidates.some((candidate) => areDirsEqual(candidate, dir)) ||
            dirHasNodeRelatedCommand(dir)) && !isUnderDir('_npx', lowCaseDir)) {
            if (canWriteToDirAndExists(dir))
                return dir;
            noWriteAccessDirs.push(dir);
        }
    }
    if (noWriteAccessDirs.length === 0) {
        throw new error_1.default('NO_GLOBAL_BIN_DIR', "Couldn't find a suitable global executables directory.", {
            hint: `There should be a node, nodejs, npm, or pnpm directory in the "${path_name_1.default}" environment variable`,
        });
    }
    if (shouldAllowWrite) {
        throw new error_1.default('GLOBAL_BIN_DIR_PERMISSION', 'No write access to the found global executable directories', {
            hint: `The found directories:
  ${noWriteAccessDirs.join('\n')}`,
        });
    }
    return noWriteAccessDirs[0];
}
const NODE_RELATED_COMMANDS = new Set(['pnpm', 'npm', 'node']);
function dirHasNodeRelatedCommand(dir) {
    try {
        return fs_1.default.readdirSync(dir, { withFileTypes: true })
            // We are searching for files or symlinks, not directories
            .filter((entry) => !entry.isDirectory())
            .map(({ name }) => name.toLowerCase())
            .some((file) => NODE_RELATED_COMMANDS.has(file.split('.')[0]));
    }
    catch (err) {
        return false;
    }
}
function isUnderDir(dir, target) {
    target = target.endsWith(path_1.default.sep) ? target : `${target}${path_1.default.sep}`;
    return target.includes(`${path_1.default.sep}${dir}${path_1.default.sep}`) ||
        target.includes(`${path_1.default.sep}.${dir}${path_1.default.sep}`);
}
function canWriteToDirAndExists(dir) {
    try {
        return can_write_to_dir_1.sync(dir);
    }
    catch (err) {
        if (err.code !== 'ENOENT')
            throw err;
        return false;
    }
}
//# sourceMappingURL=index.js.map
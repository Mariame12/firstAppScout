"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.guessDependencyType = exports.updateProjectManifestObject = void 0;
const core_loggers_1 = require("@pnpm/core-loggers");
const types_1 = require("@pnpm/types");
async function updateProjectManifestObject(prefix, packageManifest, packageSpecs) {
    packageSpecs.forEach((packageSpec) => {
        var _a, _b, _c, _d, _e;
        if (packageSpec.saveType) {
            const spec = (_a = packageSpec.pref) !== null && _a !== void 0 ? _a : findSpec(packageSpec.alias, packageManifest);
            if (spec) {
                packageManifest[packageSpec.saveType] = (_b = packageManifest[packageSpec.saveType]) !== null && _b !== void 0 ? _b : {};
                packageManifest[packageSpec.saveType][packageSpec.alias] = spec;
                types_1.DEPENDENCIES_FIELDS.filter((depField) => depField !== packageSpec.saveType).forEach((deptype) => {
                    if (packageManifest[deptype] != null) {
                        delete packageManifest[deptype][packageSpec.alias];
                    }
                });
                if (packageSpec.peer === true) {
                    packageManifest.peerDependencies = (_c = packageManifest.peerDependencies) !== null && _c !== void 0 ? _c : {};
                    packageManifest.peerDependencies[packageSpec.alias] = spec;
                }
            }
        }
        else if (packageSpec.pref) {
            const usedDepType = (_d = guessDependencyType(packageSpec.alias, packageManifest)) !== null && _d !== void 0 ? _d : 'dependencies';
            packageManifest[usedDepType] = (_e = packageManifest[usedDepType]) !== null && _e !== void 0 ? _e : {};
            packageManifest[usedDepType][packageSpec.alias] = packageSpec.pref;
        }
        if (packageSpec.nodeExecPath) {
            if (packageManifest.dependenciesMeta == null) {
                packageManifest.dependenciesMeta = {};
            }
            packageManifest.dependenciesMeta[packageSpec.alias] = { node: packageSpec.nodeExecPath };
        }
    });
    core_loggers_1.packageManifestLogger.debug({
        prefix,
        updated: packageManifest,
    });
    return packageManifest;
}
exports.updateProjectManifestObject = updateProjectManifestObject;
function findSpec(alias, manifest) {
    const foundDepType = guessDependencyType(alias, manifest);
    return foundDepType && manifest[foundDepType][alias];
}
function guessDependencyType(alias, manifest) {
    return types_1.DEPENDENCIES_FIELDS
        .find((depField) => { var _a; return Boolean((_a = manifest[depField]) === null || _a === void 0 ? void 0 : _a[alias]); });
}
exports.guessDependencyType = guessDependencyType;
//# sourceMappingURL=updateProjectManifestObject.js.map
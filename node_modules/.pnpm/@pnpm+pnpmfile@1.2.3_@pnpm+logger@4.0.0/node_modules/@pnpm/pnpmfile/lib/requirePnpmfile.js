"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BadReadPackageHookError = void 0;
const fs_1 = __importDefault(require("fs"));
const error_1 = __importDefault(require("@pnpm/error"));
const logger_1 = __importDefault(require("@pnpm/logger"));
const chalk_1 = __importDefault(require("chalk"));
class BadReadPackageHookError extends error_1.default {
    constructor(pnpmfile, message) {
        super('BAD_READ_PACKAGE_HOOK_RESULT', `${message} Hook imported via ${pnpmfile}`);
        this.pnpmfile = pnpmfile;
    }
}
exports.BadReadPackageHookError = BadReadPackageHookError;
class PnpmFileFailError extends error_1.default {
    constructor(pnpmfile, originalError) {
        super('PNPMFILE_FAIL', `Error during pnpmfile execution. pnpmfile: "${pnpmfile}". Error: "${originalError.message}".`);
        this.pnpmfile = pnpmfile;
        this.originalError = originalError;
    }
}
exports.default = (pnpmFilePath, prefix) => {
    var _a, _b;
    try {
        const pnpmfile = require(pnpmFilePath); // eslint-disable-line
        logger_1.default.info({
            message: `Using hooks from: ${pnpmFilePath}`,
            prefix,
        });
        if (typeof pnpmfile === 'undefined') {
            logger_1.default.warn({
                message: `Ignoring the pnpmfile at "${pnpmFilePath}". It exports "undefined".`,
                prefix,
            });
            return undefined;
        }
        if (((_a = pnpmfile === null || pnpmfile === void 0 ? void 0 : pnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.readPackage) && typeof pnpmfile.hooks.readPackage !== 'function') {
            throw new TypeError('hooks.readPackage should be a function');
        }
        if ((_b = pnpmfile === null || pnpmfile === void 0 ? void 0 : pnpmfile.hooks) === null || _b === void 0 ? void 0 : _b.readPackage) {
            const readPackage = pnpmfile.hooks.readPackage;
            pnpmfile.hooks.readPackage = async function (pkg, ...args) {
                var _a, _b, _c, _d;
                pkg.dependencies = (_a = pkg.dependencies) !== null && _a !== void 0 ? _a : {};
                pkg.devDependencies = (_b = pkg.devDependencies) !== null && _b !== void 0 ? _b : {};
                pkg.optionalDependencies = (_c = pkg.optionalDependencies) !== null && _c !== void 0 ? _c : {};
                pkg.peerDependencies = (_d = pkg.peerDependencies) !== null && _d !== void 0 ? _d : {};
                const newPkg = await readPackage(pkg, ...args);
                if (!newPkg) {
                    throw new BadReadPackageHookError(pnpmFilePath, 'readPackage hook did not return a package manifest object.');
                }
                const dependencies = ['dependencies', 'optionalDependencies', 'peerDependencies'];
                for (const dep of dependencies) {
                    if (newPkg[dep] && typeof newPkg[dep] !== 'object') {
                        throw new BadReadPackageHookError(pnpmFilePath, `readPackage hook returned package manifest object's property '${dep}' must be an object.`);
                    }
                }
                return newPkg;
            };
        }
        pnpmfile.filename = pnpmFilePath;
        return pnpmfile;
    }
    catch (err) { // eslint-disable-line
        if (err instanceof SyntaxError) {
            console.error(chalk_1.default.red('A syntax error in the .pnpmfile.cjs\n'));
            console.error(err);
            process.exit(1);
        }
        if (err.code !== 'MODULE_NOT_FOUND' || pnpmFileExistsSync(pnpmFilePath)) {
            throw new PnpmFileFailError(pnpmFilePath, err);
        }
        return undefined;
    }
};
function pnpmFileExistsSync(pnpmFilePath) {
    const pnpmFileRealName = pnpmFilePath.endsWith('.cjs')
        ? pnpmFilePath
        : `${pnpmFilePath}.cjs`;
    return fs_1.default.existsSync(pnpmFileRealName);
}
//# sourceMappingURL=requirePnpmfile.js.map